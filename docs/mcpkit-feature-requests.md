# mcpkit Feature Requests

**From**: mssql-mcp-server project
**mcpkit version**: 0.5.0
**Date**: 2026-01-08

This document describes limitations encountered while migrating from rmcp to mcpkit, with detailed examples of desired functionality.

---

## 1. Context Parameter Not Available in Tool Methods

### Problem

The `#[mcp_server]` macro generates tool handler methods, but there's no way to receive the `Context<'_>` parameter for progress reporting or request metadata access.

### Current Behavior

```rust
use mcpkit::prelude::*;

#[mcp_server(name = "my-server", version = "1.0.0")]
impl MyServer {
    #[tool(description = "Execute a long-running query")]
    async fn execute_query(
        &self,
        query: String,
        timeout: Option<u64>,
    ) -> Result<ToolOutput, McpError> {
        // No way to report progress during execution
        // No access to client/request metadata
        let result = self.run_query(&query).await?;
        Ok(ToolOutput::text(result))
    }
}
```

### Desired Behavior

**Option A: Context as explicit parameter**

```rust
#[mcp_server(name = "my-server", version = "1.0.0")]
impl MyServer {
    #[tool(description = "Execute a long-running query")]
    async fn execute_query(
        &self,
        ctx: &Context<'_>,  // Injected by macro when present
        query: String,
        timeout: Option<u64>,
    ) -> Result<ToolOutput, McpError> {
        // Report progress during long operations
        ctx.report_progress(0, 100, "Parsing query...").await?;

        let parsed = self.parse_query(&query)?;
        ctx.report_progress(10, 100, "Executing query...").await?;

        let result = self.run_query_with_progress(&parsed, |pct| {
            ctx.report_progress(10 + pct * 0.9, 100, "Processing rows...")
        }).await?;

        ctx.report_progress(100, 100, "Complete").await?;

        // Access request metadata for logging/tracing
        tracing::info!(
            client_id = %ctx.client_id(),
            request_id = %ctx.request_id(),
            "Query completed"
        );

        Ok(ToolOutput::text(result))
    }
}
```

**Option B: Context via attribute**

```rust
#[tool(description = "Execute query", with_context = true)]
async fn execute_query(
    &self,
    ctx: &Context<'_>,
    query: String,
) -> Result<ToolOutput, McpError> {
    // ...
}
```

### Use Cases

1. **Progress reporting for long operations**
   - Database queries that process millions of rows
   - Bulk insert operations
   - Schema analysis across many tables

2. **Request correlation for observability**
   - Correlate logs across tool invocations
   - Trace requests through the system
   - Audit logging with client identification

3. **Client-aware behavior**
   - Per-client rate limiting
   - Client-specific configuration
   - Session affinity

### Impact

Without this feature, servers cannot:
- Report meaningful progress to clients during long operations
- Implement proper observability with request correlation
- Provide client-aware functionality

**Priority**: High

---

## 2. ResourceHandler subscribe/unsubscribe Not Generated by Macro

### Problem

The `#[mcp_server]` macro generates `list_resources`, `list_resource_templates`, and `read_resource` implementations from `#[resource]` attributes, but does NOT generate `subscribe` and `unsubscribe` implementations.

### Current Behavior

```rust
#[mcp_server(name = "my-server", version = "1.0.0")]
impl MyServer {
    #[resource(
        uri_pattern = "mssql://schema/tables",
        name = "Database Tables",
        description = "List of tables in the database",
        mime_type = "application/json"
    )]
    async fn get_tables(&self, uri: &str) -> ResourceContents {
        // This works - macro generates read_resource dispatch
        ResourceContents::text(self.list_tables_json().await)
    }
}

// But ResourceHandler::subscribe and ::unsubscribe use default impl
// which just returns Ok(false), meaning subscriptions aren't supported
```

Looking at the trait:

```rust
// From mcpkit-server/src/capability/resources.rs
pub trait ResourceHandler: Send + Sync {
    async fn list_resources(&self, ctx: &Context<'_>) -> Result<Vec<Resource>, McpError>;
    async fn list_resource_templates(&self, ctx: &Context<'_>) -> Result<Vec<ResourceTemplate>, McpError>;
    async fn read_resource(&self, uri: &str, ctx: &Context<'_>) -> Result<ResourceContents, McpError>;

    // These have default implementations that return Ok(false)
    async fn subscribe(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        Ok(false)
    }
    async fn unsubscribe(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        Ok(false)
    }
}
```

### Desired Behavior

**Option A: Subscribable attribute on resources**

```rust
#[mcp_server(name = "my-server", version = "1.0.0")]
impl MyServer {
    #[resource(
        uri_pattern = "mssql://schema/tables",
        name = "Database Tables",
        description = "List of tables - subscribable for change notifications",
        mime_type = "application/json",
        subscribable = true  // <-- New attribute
    )]
    async fn get_tables(&self, uri: &str) -> ResourceContents {
        ResourceContents::text(self.list_tables_json().await)
    }

    // Macro would also look for optional subscription handlers:
    #[resource_subscribe(uri_pattern = "mssql://schema/tables")]
    async fn subscribe_tables(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        // Register subscription
        self.subscriptions.add(ctx.client_id(), uri).await;
        Ok(true)
    }

    #[resource_unsubscribe(uri_pattern = "mssql://schema/tables")]
    async fn unsubscribe_tables(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        self.subscriptions.remove(ctx.client_id(), uri).await;
        Ok(true)
    }
}
```

**Option B: Manual trait implementation alongside macro**

Allow partial manual implementation of `ResourceHandler` while still using `#[resource]` for the common cases:

```rust
#[mcp_server(name = "my-server", version = "1.0.0", manual_resource_subscriptions = true)]
impl MyServer {
    #[resource(uri_pattern = "mssql://schema/tables", ...)]
    async fn get_tables(&self, uri: &str) -> ResourceContents { ... }
}

// Separate impl for subscription handling
impl MyServer {
    // Called by the generated ResourceHandler
    pub async fn handle_subscribe(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        if uri.starts_with("mssql://schema/") {
            self.schema_subscriptions.add(ctx.client_id(), uri).await;
            return Ok(true);
        }
        Ok(false)
    }

    pub async fn handle_unsubscribe(&self, uri: &str, ctx: &Context<'_>) -> Result<bool, McpError> {
        self.schema_subscriptions.remove(ctx.client_id(), uri).await;
        Ok(true)
    }
}
```

**Option C: Notification helper on Context**

```rust
// Server can send notifications when resources change
impl MyServer {
    async fn on_table_created(&self, table_name: &str) {
        // Notify all subscribers to the schema resource
        self.notify_resource_changed("mssql://schema/tables").await;
    }
}

// Or via a NotificationSender provided by mcpkit
pub struct NotificationSender { ... }

impl NotificationSender {
    pub async fn resource_updated(&self, uri: &str) -> Result<(), McpError>;
    pub async fn resource_list_changed(&self) -> Result<(), McpError>;
}
```

### Use Cases

1. **Schema change notifications**
   - Notify clients when tables/views/procedures are created/dropped
   - Real-time schema synchronization for IDE integrations

2. **Data change notifications**
   - Notify when watched queries return different results
   - Trigger-based notifications for specific tables

3. **Configuration change notifications**
   - Server configuration updates
   - Connection pool status changes

### Impact

Without this feature, servers cannot implement real-time resource updates, which is a key MCP capability for keeping clients synchronized with server state.

**Priority**: Medium

---

## 3. No Server-Side Lifecycle Hooks

### Problem

mcpkit doesn't provide lifecycle callbacks for server events like client connect/disconnect or server start/shutdown.

### Current Behavior

```rust
// No way to hook into these events
let server = MyServer::new(config).await?;
server.serve(StdioTransport::new()).await?;
// Server runs until transport closes
// No cleanup callbacks
```

### Desired Behavior

**Option A: Trait-based lifecycle hooks**

```rust
use mcpkit::prelude::*;

#[mcp_server(name = "my-server", version = "1.0.0")]
impl MyServer {
    // Existing tool/resource implementations...
}

// Implement optional lifecycle trait
impl ServerLifecycle for MyServer {
    async fn on_server_start(&self, info: &ServerInfo) -> Result<(), McpError> {
        tracing::info!("Server started: {}", info.name);
        self.initialize_background_tasks().await;
        Ok(())
    }

    async fn on_server_shutdown(&self) -> Result<(), McpError> {
        tracing::info!("Server shutting down...");
        self.cleanup_all_sessions().await;
        self.close_connection_pool().await;
        Ok(())
    }

    async fn on_client_connect(&self, client: &ClientInfo) -> Result<(), McpError> {
        tracing::info!(client_id = %client.id, "Client connected");
        self.create_client_session(client.id).await;
        Ok(())
    }

    async fn on_client_disconnect(&self, client_id: &str) -> Result<(), McpError> {
        tracing::info!(client_id = %client_id, "Client disconnected");
        // Clean up client-specific resources
        self.rollback_client_transactions(client_id).await;
        self.cleanup_client_temp_tables(client_id).await;
        self.remove_client_session(client_id).await;
        Ok(())
    }
}
```

**Option B: Callback registration**

```rust
let server = MyServer::new(config).await?;

server.on_client_connect(|client| async {
    tracing::info!("Client {} connected", client.id);
    Ok(())
});

server.on_client_disconnect(|client_id| async {
    cleanup_client_resources(client_id).await;
    Ok(())
});

server.serve(StdioTransport::new()).await?;
```

**Option C: Event channel**

```rust
let server = MyServer::new(config).await?;
let mut events = server.events(); // Returns broadcast channel receiver

tokio::spawn(async move {
    while let Some(event) = events.recv().await {
        match event {
            ServerEvent::ClientConnected(info) => { ... }
            ServerEvent::ClientDisconnected(id) => { ... }
            ServerEvent::ServerStarted => { ... }
            ServerEvent::ShutdownRequested => { ... }
        }
    }
});

server.serve(StdioTransport::new()).await?;
```

### Use Cases

1. **Resource cleanup on client disconnect**
   - Roll back open transactions
   - Drop temporary tables created by the client
   - Release pinned connections back to pool
   - Cancel running async queries

2. **Audit logging**
   - Log all client connections/disconnections
   - Track session duration
   - Compliance and security auditing

3. **Per-client state management**
   - Initialize client-specific caches
   - Set up client session context
   - Track client capabilities for feature negotiation

4. **Graceful shutdown**
   - Drain active requests
   - Persist state before shutdown
   - Notify clients of impending shutdown

### Current Workaround

We maintain our own session tracking with timeout-based cleanup, but this is imperfect:

```rust
// Our current approach - not ideal
pub struct SessionManager {
    sessions: HashMap<String, ClientSession>,
    timeout: Duration,
}

impl SessionManager {
    // We have to guess when clients disconnect via timeout
    pub async fn cleanup_expired(&self) {
        let now = Instant::now();
        for (id, session) in self.sessions.iter() {
            if now.duration_since(session.last_activity) > self.timeout {
                // Assume client disconnected - but we don't really know
                self.cleanup_session(id).await;
            }
        }
    }
}
```

This has problems:
- Delayed cleanup (must wait for timeout)
- False positives (slow clients marked as disconnected)
- No way to know about graceful disconnects
- Wasted resources during timeout window

### Impact

Without lifecycle hooks, servers cannot reliably manage per-client state, leading to resource leaks, orphaned transactions, and incomplete cleanup.

**Priority**: Medium

---

## 4. No Access to Request/Client Metadata in Handlers

### Problem

Tool, resource, and prompt handlers cannot access request-level metadata for logging, tracing, or client-aware behavior.

### Current Behavior

```rust
#[tool(description = "Execute query")]
async fn execute_query(&self, query: String) -> Result<ToolOutput, McpError> {
    // No way to know:
    // - Which client is making this request
    // - Request ID for correlation
    // - Client capabilities
    // - Session information

    tracing::info!("Executing query"); // Can't correlate this log entry

    let result = self.run_query(&query).await?;
    Ok(ToolOutput::text(result))
}
```

### Desired Behavior

```rust
#[tool(description = "Execute query")]
async fn execute_query(
    &self,
    ctx: &Context<'_>,
    query: String,
) -> Result<ToolOutput, McpError> {
    // Access client information
    let client_id = ctx.client_id();
    let request_id = ctx.request_id();

    // Structured logging with correlation
    tracing::info!(
        client_id = %client_id,
        request_id = %request_id,
        query_preview = %truncate(&query, 100),
        "Executing query"
    );

    // Client-aware behavior
    let timeout = self.get_client_timeout(client_id).await;

    // Rate limiting per client
    self.rate_limiter.check(client_id).await?;

    let result = self.run_query_with_timeout(&query, timeout).await?;

    tracing::info!(
        client_id = %client_id,
        request_id = %request_id,
        rows = result.row_count,
        "Query completed"
    );

    Ok(ToolOutput::text(result.to_string()))
}
```

### Context API Wishlist

```rust
pub struct Context<'a> {
    // ... existing fields
}

impl<'a> Context<'a> {
    /// Unique identifier for the connected client
    pub fn client_id(&self) -> &str;

    /// Unique identifier for this specific request
    pub fn request_id(&self) -> &str;

    /// Client capabilities negotiated during initialization
    pub fn client_capabilities(&self) -> &ClientCapabilities;

    /// Client info provided during initialization
    pub fn client_info(&self) -> Option<&ClientInfo>;

    /// Report progress for long-running operations
    pub async fn report_progress(
        &self,
        current: u64,
        total: u64,
        message: &str
    ) -> Result<(), McpError>;

    /// Check if the client has requested cancellation
    pub fn is_cancelled(&self) -> bool;

    /// Get a cancellation token for async operations
    pub fn cancellation_token(&self) -> CancellationToken;
}
```

### Use Cases

1. **Observability and tracing**
   - Correlate logs across a request lifecycle
   - Integrate with OpenTelemetry/distributed tracing
   - Debug issues for specific clients

2. **Per-client behavior**
   - Different timeouts per client
   - Client-specific rate limits
   - Feature flags based on client capabilities

3. **Security and auditing**
   - Log all operations with client identification
   - Implement per-client access controls
   - Compliance logging

4. **Cancellation support**
   - Check if client cancelled the request
   - Abort long-running operations early
   - Clean up partial work on cancellation

### Impact

Without request metadata, servers cannot implement proper observability, client-aware features, or request correlation, which are essential for production deployments.

**Priority**: Medium (High if combined with #1 Context access)

---

## Summary

| Feature | Priority | Complexity Estimate |
|---------|----------|---------------------|
| Context in tool methods | High | Medium - macro changes |
| Resource subscriptions | Medium | Medium - macro + trait changes |
| Lifecycle hooks | Medium | Low - trait addition |
| Request metadata | Medium | Low - if Context is added |

### Recommended Implementation Order

1. **Context access in handlers** (solves #1 and #4 together)
   - Add optional `ctx: &Context<'_>` parameter support to `#[tool]`, `#[resource]`, `#[prompt]` macros
   - Include client_id, request_id, and progress reporting in Context

2. **Lifecycle hooks** (#3)
   - Add `ServerLifecycle` trait with default implementations
   - Wire into transport layer for connect/disconnect events

3. **Resource subscriptions** (#2)
   - Add `subscribable` attribute to `#[resource]`
   - Generate subscribe/unsubscribe dispatch
   - Provide notification sending mechanism

---

## Contact

If you need more details, example code, or want to discuss implementation approaches, please reach out. We're happy to:

- Provide more detailed use cases
- Test pre-release implementations
- Contribute PRs if given guidance on preferred approach
